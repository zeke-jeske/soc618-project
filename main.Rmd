---
title: "Commuting Network Analysis Project"
author: "Zeke Jeske"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = TRUE, message = TRUE)

# Fetch and load the data
source("setup.R")

# Load additional packages for visualization
suppressPackageStartupMessages({
  library(igraph)
  library(tidygraph)
  library(ggraph)
  library(tmap)
  library(ggrepel)
  library(blockmodeling)
})
```

# Final Visualizations

## Introductory Visualizations

```{r utility-functions}
create_graph <- function(flows) {
  g <- tbl_graph(edges = flows) %>%
    activate(edges) %>%
    # Make edges weighted by flow size
    mutate(weight = n) %>%
    activate(nodes) %>%
    # For some reason simply passing `nodes = ccas` doesn't work, but this does the same
    left_join(ccas, by = "name") %>%
    # Compute centrality measures
    mutate(
      in_degree = centrality_degree(weights = n, mode = "in"),
      out_degree = centrality_degree(weights = n, mode = "out"),
      eigen = centrality_eigen(weights = n, directed = TRUE, scale = TRUE)
    )
}

g2002 <- create_graph(cca_flows_2002)
g2022 <- create_graph(cca_flows_2022)
# Get the commuting network for the given year
g <- function(year) {
  if (year == 2002) {
    g2002
  } else if (year == 2022) {
    g2022
  } else {
    stop("Only years allowed are 2002 and 2022")
  }
}

get_sf <- function(year) {
  g(year) %>%
    activate(nodes) %>%
    as_tibble() %>%
    st_as_sf()
}
```

```{r}
# Number of nodes
g2022 %>% vcount()
# Number of non-zero edges
g2022 %E>% filter(n > 0) %>% ecount()
```

```{r network-plot, fig.width=12, fig.height=8}
set.seed(1)
g2022 %>%
  activate(edges) %>%
  mutate(weight = n) %>%
  filter(weight > quantile(weight, 0.6)) %>% # Keep only the biggest flows
  activate(nodes) %>%
  # Meters to km
  mutate(distance_from_loop = distance_from_loop / 1000) %>%
  ggraph(layout = "fr") +
  geom_edge_link(
    aes(edge_alpha = weight),
    edge_width = 0.2, edge_color = "#000",
  ) +
  geom_node_point(aes(color = distance_from_loop), size = 3) +
  geom_node_text(aes(label = name), repel = TRUE, size = 3) +
  theme_void() +
  theme_graph(
    plot_margin = margin(10, 10, 10, 10),
  ) +
  theme(
    legend.background = element_rect(),
    legend.margin = margin(8,8,8,8),
    legend.position = "inside",
    legend.position.inside = c(0.95, 0.05),
    legend.justification = c(1, 0),
    legend.box.just = "right",
    legend.box.margin = margin(6, 6, 6, 6),
  ) +
  labs(
    color = "Distance from the Loop, km",
    edge_alpha = "Commuting flow"
  )
```
## In-degree, out-degree, and eigenvector centrality

```{r in-degree-plot}
# Higher-order function to create map plotting functions that change fill according to some variable
map_by <- function(variable, legend_label, title, scale) {
  function(year) {
    get_sf(year) %>%
      tm_shape() +
      tm_polygons(
        fill = variable,
        fill.legend = tm_legend(title = legend_label),
        fill.scale = scale,
      ) +
      tm_title(glue("{title} ({year})"))
  }
}

map_in_degree <- map_by("in_degree", "In-commuting flow", "Inter-CCA In-commuting", tm_scale_continuous_log(values = "brewer.oranges", limits = c(100, 300000)))

map_in_degree(2002)
map_in_degree(2022)
```

```{r out-degree-plot}
map_out_degree <- map_by("out_degree", "Out-commuting flow", "Inter-CCA Out-commuting", tm_scale_continuous_log(values = "brewer.blues", limits = c(500, 40000)))

# Side by side
tmap_arrange(map_out_degree(2002), map_out_degree(2022))
```

```{r}
map_eigen <- map_by("eigen", "Eigenvector centrality", "Eigenvector Centrality",
  tm_scale_continuous_log(values = "viridis", limits = c(0.0001, 1)))
map_eigen(2002)
map_eigen(2022)
```

```{r eigen-vs-distance, eval = FALSE}
cca_graph %N>%
  as_tibble() %>%
  mutate(area = if_else(
    st_centroid(geometry) %>% st_coordinates() %>% .[, 2] >=
      st_centroid(filter(ccas, name == "Near West Side")$geometry) %>%
        st_coordinates() %>%
        .[, 2],
    "Northern",
    "Southern"
  )) %>%
  arrange(desc(eig_centrality)) %>%
  ggplot(aes(x = distance_from_loop, y = eig_centrality)) +
  geom_point(aes(color = area)) +
  geom_smooth(se = FALSE, method = "lm", size = 0.5, color = "black", formula = y ~ x) +
  # geom_smooth(aes(color = area), se = FALSE, method = "lm", size = 0.5) +
  geom_text_repel(aes(label = name), size = 2) +
  scale_y_log10() +
  scale_color_brewer(palette = "Set1") +
  theme_classic() +
  labs(
    title = "Eigenvector Centrality vs. Distance from the Loop",
    subtitle = '"Northern" neighborhoods are those that are at least as far north as the Near West Side.',
    x = "Distance from the Loop (m)",
    y = "Eigenvector Centrality",
    color = "Area"
  )
```

## In-entropy and out-entropy

`igraph` implements entropy with the `diversity()` function, but only for undirected graphs, so
we'll have to implement in- and out-entropy ourselves.

```{r}
# A generic function to compute the in- or out-entropy value for a single node,
# given a vector of its in- or out-commuting flows.
entropy <- function(values, n = length(values)) {
  normed <- values / sum(values)
  # 0 values don't contribute to the sum
  -sum(ifelse(normed == 0, 0, normed * log2(normed))) / log2(n)
}

# Tests
entropy(c(5, 5, 5), 3) == 1
entropy(c(0,0,100), 3) == 0
entropy(c(100), 3) == 0
```

```{r}
# Add in-entropy and out-entropy to the network objects!
add_in_entropy <- function(g) {
  if ("in_entropy" %in% colnames(g %N>% as_tibble())) {
    warning("In-entropy has already been computed. Skipping.")
    return(g)
  }

  g %>%
    activate(nodes) %>%
    mutate(
      in_entropy = map_dbl(1:vcount(g), \(node) {
        # Get all in-commuting flows to this node
        g %>%
          activate(edges) %>%
          filter(to == node) %>%
          pull(n) %>%
          # Maximum number of edges to this node is 1 less than total nodes
          entropy(num_nodes - 1)
      })
    )
}

add_out_entropy <- function(g) {
  if ("out_entropy" %in% colnames(g %N>% as_tibble())) {
    warning("Out-entropy has already been computed. Skipping.")
    return(g)
  }

  g %>%
    activate(nodes) %>%
    mutate(
      out_entropy = map_dbl(1:vcount(g), \(node) {
        # Get all out-commuting flows from this node
        g %>%
          activate(edges) %>%
          filter(from == node) %>%
          pull(n) %>%
          # Maximum number of edges from this node is 1 less than total nodes
          entropy(vcount(g) - 1)
      })
    )
}

g2002 <- g2002 %>% add_in_entropy() %>% add_out_entropy()
g2022 <- g2022 %>% add_in_entropy() %>% add_out_entropy()
```

```{r}
map_in_entropy <- map_by("in_entropy", "In-commuting entropy", "In-entropy",
  tm_scale_continuous_log(values = "brewer.reds", limits = c(0.75, 1)))
map_in_entropy(2022)
map_in_entropy(2002)
```

```{r}
map_out_entropy <- map_by("out_entropy", "Out-commuting entropy", "Out-entropy",
  tm_scale_continuous_log(values = "brewer.purples", limits = c(0.4, 0.9)))
map_out_entropy(2022)
map_out_entropy(2002)
```

```{r, eval = FALSE}
# TODO
compare_years_plot <- function(variable) {
  g1 <- g(2002)
  g2 <- g(2022)
  
}
```

## K-cores

```{r}
g(2002) %>%
  activate(edges) %>%
  filter(n > quantile(n, 0.75)) %>%
  activate(nodes) %>%
  mutate(coreness = node_coreness()) %>%
  as_tibble() %>%
  st_as_sf() %>%
  tm_shape() +
  tm_polygons(fill = "coreness", fill.scale = tm_scale_ordinal())
```

## Structural equivalence

```{r}
get_dend <- function(g) {
  adj <- as_adjacency_matrix(g, attr = "n", sparse = FALSE)
  # Group community areas with similar in *and* out commuting
  mtx_both <- rbind(adj, t(adj))

  # Perform agglomerative clustering based on pairwise Pearson's correlations
  hclust(as.dist(1 - cor(mtx_both), upper = FALSE), method = "ward.D")
}
add_structural_equiv <- function(g) {
  if ("cluster" %in% colnames(g %N>% as_tibble())) {
    g <- g %>% select(-cluster)
  }

  dendrogram <- get_dend(g)
  # plot(dendrogram)

  # Elbow plot shows that 5 clusters is a good choice for both years
  # heights <- dendrogram$height
  # num_clusters <- length(heights):1
  # tibble(height = heights, num_clusters = num_clusters) %>%
  #   filter(num_clusters <= 20) %>%
  #   ggplot(aes(x = num_clusters, y = height)) +
  #   geom_point() +
  #   geom_line()

  cluster_assignments <- cutree(dendrogram, k = 5) %>%
    tibble(cluster = ., name = names(cluster))
  # Add column to graph
  g %>%
    activate(nodes) %>%
    left_join(cluster_assignments, by = "name")
}

g2002 <- add_structural_equiv(g2002)
g2022 <- add_structural_equiv(g2022)

map_struct_equiv <- map_by("cluster", "Structural equivalence class", "Structural Equivalence Clusters", scale = tm_scale_categorical())
tmap_arrange(map_struct_equiv(2002), map_struct_equiv(2022))

plot(get_dend(g2002))
plot(get_dend(g2022))
```

## Regular equivalence/blockmodeling

```{r}
mat <- as_adjacency_matrix(g2002, attr = "n", sparse = FALSE)
rege <- REGE.nm.for(mat)$E
dend <- hclust(as.dist(1 - rege), method = "ward.D")

plot(dend)

plot.mat(mat, clu=cutree(dend, k=8))
```

# Feedback 4/17/25

- Literature:
  - Check labor literature; Detroit
  - Redlining, history of Chicago
  - Gold Coast/Slum book. Great American City book.
  - Rob Simson (?)
- Issues with the regression idea:
  - Disruptions in 2008 and 2020
  - Would have to control for a lot of things: population, overall economic change
    (shouldn't be too hard)
- Misc
  - **How is virtual work captured in the survey?**
  - Compute degree without self-ties so what we're measuring is **cross-neighborhood
    commuting** patterns
  - Justify my choice of Chicago as the boundary
- Alternative ideas:
  - Just narrow to COVID time frame, see what changed in the data
  - Only do descriptive statistics. Longitudinal preferably. Could use blockmodeling
    or community detection techniques or structural/regular equivalence.

# Old Ideas

## Where people who live in a given CCA work?

One simple result we can draw from this dataset is simply where people who live in
any given commuting area work. For example, below we compare the commuting flows for
residents of Hyde Park and Woodlawn. Hyde Park and Woodlawn are adjacent, but
because Hyde Park is home to the University of Chicago, most of its residents work there.
Woodlawn, on the other hand, has a shortage of local jobs, so most Woodlawn residents
commute to the Loop.

```{r where-people-work-functions, eval = FALSE}
where_do_people_work <- function(cca) {
  cca_flows_2022 %>%
    filter(from == cca) %>%
    select(to, n) %>%
    arrange(desc(n))
}
where_do_people_work_plot <- function(cca) {
  # For debugging:
  # cca <- "Woodlawn"
  
  where_do_people_work(cca) %>%
    filter(to != "OUTSIDE CHICAGO") %>%
    mutate(is_source = to == cca) %>%
    # Put the source community last so that its borders are on top (plotted last)
    arrange(is_source) %>%
    # Must be left_join so that OUTSIDE CHICAGO is left out
    left_join(ccas, by = c("to" = "name")) %>%
    # If you want to use a log scale, try this
    # mutate(log_n = log10(n + 1)) %>%
    st_as_sf() %>%
    tm_shape() +
    tm_polygons(
      fill = "n",
      fill.legend = tm_legend(title = "Number of Workers"),
      col = "is_source",
      col.scale = tm_scale_categorical(values = c(`TRUE` = "red", `FALSE` = "lightblue", `NA` = "lightblue")),
      col.legend = tm_legend_hide(),
      lwd = "is_source",
      lwd.scale = tm_scale_categorical(values = c(`TRUE` = 2, `FALSE` = 0.5)),
      lwd.legend = tm_legend_hide(),
    ) +
    tm_title(
      glue("Where do {cca} residents work?"),
      size = 1.5
    )
}
where_do_people_work_plot("Woodlawn")
where_do_people_work_plot("Hyde Park")
```


## In and out degree

In degree (number who work in this community area) is recorded in the `w_total` column:

```{r in-degree, eval = FALSE}
ccas %>%
  as_tibble() %>%
  select(name, w_total) %>%
  filter(name != "OUTSIDE CHICAGO") %>%
  arrange(desc(w_total)) %>%
  head(6)
```

```{r in-degree-plot, eval = FALSE}
ccas %>%
  filter(name != "OUTSIDE CHICAGO") %>%
  tm_shape() +
  tm_polygons(
    fill = "w_total",
    fill.legend = tm_legend(title = "Jobs"),
    fill.scale = tm_scale_continuous_log10(values = "viridis"),
  )
```

The commuting areas with the most jobs are those in the central city (the Loop, Near North
Side, Near West Side, and West Town) or those that contain a major employer (O'Hare
and Hyde Park).

Out degree (number of workers who live in this community area) is recorded in the `h_total` column:

```{r out-degree, eval = FALSE}
ccas %>%
  as_tibble() %>%
  select(name, h_total) %>%
  filter(name != "OUTSIDE CHICAGO") %>%
  arrange(desc(h_total)) %>%
  head(10)
```

```{r out-degree-plot, eval = FALSE}
ccas %>%
  filter(name != "OUTSIDE CHICAGO") %>%
  tm_shape() +
  tm_polygons(
    fill = "h_total",
    fill.legend = tm_legend(title = "Employed Residents"),
    fill.scale = tm_scale_continuous_log10(values = "viridis"),
  )
```

Out degree isn't characterized by a few extreme outliers like in degree is. However, notice the
clear trend on the map: North Side neighborhoods tend to have more working residents than South Side
neighborhoods, where unemployment tends to be higher.

```{r in-out-degree-scatter, eval = FALSE}
ccas %>%
  select(name, w_total, h_total) %>%
  filter(name != "OUTSIDE CHICAGO") %>%
  ggplot(aes(x = h_total, y = w_total)) +
  geom_point() +
  # geom_smooth(se = FALSE, method = "lm", size = 0.5) +
  geom_text_repel(aes(label = name), size = 2, max.overlaps = 2) +
  scale_y_log10() +
  theme_minimal() +
  labs(
    title = "In Degree vs. Out Degree",
    x = "Employed residents (out degree)",
    y = "Jobs (in degree)"
  )
```

Not surprisingly, neighborhoods with more working residents tend to also have more jobs.


## Local jobs availability

This plot shows the number of local jobs per working resident in each community area. In neighborhoods
with the largest employment, like O'Hare and the Loop, there are many more jobs than working
residents. By contrast, many neighborhoods have nearly ten times as many working residents as jobs,
so almost everyone must commute.

```{r jobs-availability, eval = FALSE}
ccas <- ccas %>%
  mutate(jobs_availability = w_total / h_total)

ccas %>%
  # filter(name != "Loop", , name != "Ohare") %>%
  # mutate(pct_work_in_same = work_in_same / w_total * 100) %>%
  tm_shape() +
  tm_polygons(
    fill = "jobs_availability",
    fill.legend = tm_legend(title = "Jobs Availability"),
    fill.scale = tm_scale_continuous_log10(values = "viridis"),
  )
```

## Distance and flow size

Intuitively, we would expect that commuting is higher between neighborhoods that are closer together.

```{r distance-vs-size, eval = FALSE}
cca_flows_2022 %>%
  filter(from != "OUTSIDE CHICAGO", to != "OUTSIDE CHICAGO") %>%
  # Zero flows don't work with the log scale
  filter(n != 0) %>%
  # Setting amount = 1 makes the y-scale get wacky
  ggplot(aes(x = distance, y = jitter(n, amount = 0.99))) +
  # geom_density2d_filled() +
  geom_point(size = 1, alpha = 0.3) +
  # geom_smooth(se = FALSE, method = "lm", size = 1, color = "steelblue") +
  # scale_x_log10() +
  scale_y_log10() +
  # scale_y_continuous(limits = c(0, 100)) +
  theme_minimal() +
  guides(fill = "none") +
  labs(
    title = "Distance vs. Flow Size",
    x = "Distance (m)",
    y = "Flow Size"
  )
```

## Modeling Commuting Patterns with an ERGM

Modeling this dataset with an exponential random graph model (ERGM) would help understand what factors determine where people
work. However, the ERGMs we learned about in class only work with unweighted networks.
Krivitsky (2012) extended the ERGM framework to networks with values that represent counts,
which is what we have here.

```{r ergm-setup, eval = FALSE}
chicago_only <- cca_graph %N>%
  filter(name != "OUTSIDE CHICAGO")

net <- asNetwork(chicago_only)

# Add node covariates
net %v% "residents_log" <- log(chicago_only %N>% pull(h_in_chicago))
net %v% "workers_log" <- log(chicago_only %N>% pull(w_from_chicago))

# Network covariate: geographic distances
# Make a full distance matrix. Recall that all dyads are represented in
# cca_flows, not just non-zero edges.
D <- cca_flows_2022 %>%
  filter(from != "OUTSIDE CHICAGO", to != "OUTSIDE CHICAGO") %>%
  select(from, to, distance) %>%
  pivot_wider(names_from = to, values_from = distance) %>%
  column_to_rownames("from") %>%
  as.matrix()
```

```{r ergm-1, eval = FALSE}
fit1 <- ergm(
  net ~
    sum + # baseline intensity
    nonzero + # sparsity
    nodeocov("residents_log") + # origin size effect
    nodeicov("workers_log") + # destination size effect
    edgecov(D), # deterrence by distance
  reference = ~Poisson,
  response = "n",
)
```
